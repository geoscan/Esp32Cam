//
// Api.impl
//
// Created on: Feb 09, 2022
//     Author: Dmitry Murashov (d.murashov@geoscan.aero)
//

#include "Api.hpp"  // For syntax highlighting

namespace Sock {

template <class TbufferType>
std::size_t Api::sendTo(const asio::ip::tcp::endpoint &aEndpoint, std::uint16_t aLocalPort,  TbufferType &&aBuffer,
	asio::error_code &aErr)
{
	auto it = container.tcpConnected.find(aEndpoint, aLocalPort);

	if (it == container.tcpConnected.end()) {
		return asio::error::not_connected;
	}

	{
		std::lock_guard<std::mutex> lock{syncAsyncMutex};
		(void)lock;

		return it->write_some(std::forward<TbufferType>(aBuffer), aErr);
	}
}

template <class TbufferType>
std::size_t Api::sendTo(const asio::ip::udp::endpoint &aRemoteEndpoint, std::uint16_t &aLocalPort,  TbufferType &&aBuffer,
	asio::error_code &aErr, asio::ip::udp aUdp)
{
	auto it = container.udp.find(aRemoteEndpoint, aLocalPort);

	if (it == container.udp.end()) {
		if (aLocalPort != 0) {
			it = container.udp.emplace(container.udp.end(), ioContext, asio::ip::udp::endpoint{aUdp, aLocalPort});
		} else {
			it = container.udp.emplace(container.udp.end(), ioContext);
			aLocalPort = it->local_endpoint(aErr).port();
		}
		udpAsyncReceiveFrom(*it);
	}

	{
		std::lock_guard<std::mutex> lock{syncAsyncMutex};
		(void)lock;

		return it->send_to(std::forward<TbufferType>(aBuffer), aRemoteEndpoint, 0, aErr);
	}
}

}  // namespace Sock
