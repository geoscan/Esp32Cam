//
// Api.impl
//
// Created on: Feb 09, 2022
//     Author: Dmitry Murashov (d.murashov@geoscan.aero)
//

#include "Api.hpp"  // For syntax highlighting

namespace Sock {

template <class TbufferType>
std::size_t Api::sendTo(const asio::ip::tcp::endpoint &aEndpoint, std::uint16_t aLocalPort,  TbufferType &&aBuffer,
	asio::error_code &aErr)
{
	std::lock_guard<std::mutex> lock{syncAsyncMutex};
	(void)lock;
	auto it = container.tcpConnected.find(aEndpoint, aLocalPort);

	if (it == container.tcpConnected.end()) {
		ESP_LOGW(kDebugTag, "sendTo(TCP) %s : %d on port %d - no such socket was found",
			aEndpoint.address().to_string().c_str(), aEndpoint.port(), aLocalPort);
		return asio::error::not_connected;
	}

	return it->write_some(std::forward<TbufferType>(aBuffer), aErr);
}

template <class TbufferType>
std::size_t Api::sendTo(const asio::ip::udp::endpoint &aRemoteEndpoint, std::uint16_t &aLocalPort,  TbufferType &&aBuffer,
	asio::error_code &aErr, asio::ip::udp aUdp)
{
	std::lock_guard<std::mutex> lock{syncAsyncMutex};
	(void)lock;
	auto it{container.udp.end()};
	aErr.clear();

	if (0 != aLocalPort) {
		it = container.udp.find(aLocalPort);
	}

	if (it == container.udp.end()) {
		it = container.udp.emplace(container.udp.end(), ioContext);

		it->open(aUdp, aErr);

		if (!aErr) {
			it->bind(asio::ip::udp::endpoint{aUdp, aLocalPort}, aErr);
		}

		if (!aErr) {
			aLocalPort = it->local_endpoint(aErr).port();
		}

		if (!aErr) {
			ESP_LOGI(kDebugTag, "sendTo(UDP) %s : %d - no such socket was found, created on port %d",
				aRemoteEndpoint.address().to_string().c_str(), aRemoteEndpoint.port(), aLocalPort);
			udpAsyncReceiveFrom(*it);
		}
	}

	std::size_t ret = 0;

	if (container.udp.end() != it) {
		ret = it->send_to(std::forward<TbufferType>(aBuffer), aRemoteEndpoint, 0, aErr);
	}

	return ret;
}

}  // namespace Sock
